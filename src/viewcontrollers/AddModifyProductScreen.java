package viewcontrollers;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import model.Inventory;
import model.Part;
import model.Product;
import viewcontrollers.AddModifyController;

import java.io.IOException;
import java.net.URL;
import java.util.ResourceBundle;

import static model.Inventory.*;
import static model.Utilities.generateId;
import static model.Utilities.populatePartsTable;

/** Manages user interaction with the screens used to add and modify Products. */
public class AddModifyProductScreen extends AddModifyController implements Initializable {

    public TableView<Part> partsTable;
    public TableColumn<Part, Integer> partId;
    public TableColumn<Part, String> partName;
    public TableColumn<Part, Integer> partStock;
    public TableColumn<Part, Double> partPrice;

    public TableView<Part> associatedPartsTable;
    public TableColumn<Part, Integer> assocPartId;
    public TableColumn<Part, String> assocPartName;
    public TableColumn<Part, Integer> assocPartStock;
    public TableColumn<Part, Double> assocPartPrice;

    private ObservableList<Part> associatedPartsBuffer = FXCollections.observableArrayList();

    /** Initializes this controller. Check for the presence of a Product to be modified in the selectedProduct static
     *  Product variable, and renders the associated view as the "Modify Product" screen if such data is available,
     *  pre-populating the Product's data into the appropriate text fields for editing. */
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        // Render the part to be modified if one was passed in.
        Product selectedProduct = getSelectedProduct();
        if(selectedProduct != null) {
            title.setText("Modify Product");
            idField.setText(Integer.toString(selectedProduct.getId()));
            nameField.setText(selectedProduct.getName());
            invField.setText(Integer.toString(selectedProduct.getStock()));
            priceField.setText(Double.toString(selectedProduct.getPrice()));
            maxField.setText(Integer.toString(selectedProduct.getMax()));
            minField.setText(Integer.toString(selectedProduct.getMin()));

            associatedPartsBuffer = FXCollections.observableArrayList(selectedProduct.getAllAssociatedParts());
        }
        populatePartsTable(getAllParts(), partsTable, partId, partName, partStock, partPrice);
        populatePartsTable(associatedPartsBuffer, associatedPartsTable, assocPartId, assocPartName,
                    assocPartStock, assocPartPrice);
    }

    /** Event handler for the save button. Either updates an existing Product or adds a new Product to Inventory, if input
     * passes validation testing.
     *
     * @param actionEvent The event generated by interacting with the save button.
     */
    public void onSave(ActionEvent actionEvent) throws IOException{
        Product newProduct;
        newProduct = getProductFromFields();

        try {
            assert newProduct != null;
        } catch(NullPointerException e) {
            System.out.println("the newProduct object you are trying to save is null.");
            loadMainScene((Stage) title.getScene().getWindow());
        }

        if(validProductFields(newProduct)) {
            if(title.getText().equals("Add Product")) {
                addProduct(newProduct);
            } else if(title.getText().equals("Modify Product")) {
                Product product = getSelectedProduct();
                newProduct.setId(product.getId());
                updateProduct(product, newProduct);
            }
            loadMainScene((Stage) title.getScene().getWindow());
        } else {
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle("Invalid Product Fields");
            alert.setContentText("Max must be more than Min and Stock/Inv must be between those values.");
            alert.showAndWait();
        }
    }

    /** Validates a Product's Max, Min, and Stock/Inv fields to ensure they do not contradict one another.
     *
     * @param newProduct A newly generated Product to be validated.
     * @return True if validation testing is passed, and False otherwise.
     */
    private boolean validProductFields(Product newProduct) {
        return newProduct.getMin() < newProduct.getMax() && newProduct.getStock() >= newProduct.getMin()
                && newProduct.getStock() <= newProduct.getMax();
    }

    /** Replaces the given Product with the given newPart.
     *
     * @param product The Product to be replaced.
     * @param newProduct The replacement Product.
     */
    public void updateProduct(Product product, Product newProduct) {
        int indexOfProduct = Inventory.getAllProducts().indexOf(product);
        Inventory.updateProduct(indexOfProduct, newProduct);
        setSelectedProduct(null);
    }

    /** Event handler for the Cancel button.
     *
     * @param actionEvent The event generated via interaction with the Cancel button.
     */
    public void onCancel(ActionEvent actionEvent) throws IOException {
        loadMainScene((Stage) title.getScene().getWindow());
    }

    /** Event handler for the Add Part button - Adds the selected Part to this Product's associated Parts list.
     *
     * @param actionEvent The event generated by interaction with this Product's Add Part button.
     */
    public void onAdd(ActionEvent actionEvent) {
        Part selectedPart = partsTable.getSelectionModel().getSelectedItem();
        try {
            associatedPartsBuffer.add(selectedPart);
        } catch(NullPointerException e) {
            e.printStackTrace();
        }
    }

    /** Event handler for the Remove Part button - removes the selected Part from this Product's associated Parts list.
     *
     * @param actionEvent The event generated by interaction with this Product's Remove Part button.
     */
    public void onRemove(ActionEvent actionEvent) {
        Part selectedPart = associatedPartsTable.getSelectionModel().getSelectedItem();
        if(selectedPart != null) {
            Alert alert = new Alert(Alert.AlertType.CONFIRMATION, selectedPart.getName() +
                    " will be removed from the associated parts list for this product. Are you sure?",
                    ButtonType.YES, ButtonType.NO);
            alert.showAndWait();
            if (alert.getResult() == ButtonType.YES) {
                try {
                    associatedPartsBuffer.remove(selectedPart);
                } catch(NullPointerException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /** Event handler for the Part search box. Triggered when enter is pressed while the search box is selected.
     *
     * @param keyEvent The event generated by the user when a key is pressed while the search box is selected.
     */
    public void onSearchKeyPress(KeyEvent keyEvent) {
        if(keyEvent.getCode().equals(KeyCode.ENTER)) {
            TextField field = (TextField) keyEvent.getSource();
            String searchTerm = field.getText();
            ObservableList<Part> parts = FXCollections.observableArrayList();
            try {
                int id = Integer.parseInt(searchTerm);
                parts.add(lookupPart(id));
            } catch(NumberFormatException e) {
                parts = Inventory.lookupPart(searchTerm.toLowerCase());
            }
            if(parts.isEmpty()) {
                Alert alert = new Alert(Alert.AlertType.ERROR);
                alert.setTitle("Part(s) Not Found");
                alert.setContentText("No matching parts were found!");
                alert.showAndWait();
            }
            populatePartsTable(parts, partsTable, partId, partName, partStock, partPrice);
        }
    }

    /** Validate and extract values from the current view, converting them into a Product
     * LOGICAL ERROR: Encountered a bug where editing a part or product causes the edited object (which is, in fact, a new object)
     * to be assigned the next ID in the appropriate object category, causing the edited item's old ID to be lost. I eventually fixed
     * this by adding logic to the onSave method (line 69) which assigns the old ID to the replacement item before
     * assignment to Inventory (line 86).
     *
     * @return A new Product.
     */
    public Product getProductFromFields() {
        String name = nameField.getText();
        int inv = 0;
        if(validateIntInput(invField.getText())) {
            inv = Integer.parseInt(invField.getText());
        }
        double price = 0;
        if(validateDoubleInput(priceField.getText())) {
            price = Double.parseDouble(priceField.getText());
        }
        int max = 1;
        if(validateIntInput(maxField.getText())) {
            max = Integer.parseInt(maxField.getText());
        }
        int min = 0;
        if(validateIntInput(minField.getText()) && min < max) {
            min = Integer.parseInt(minField.getText());
        }
        ObservableList<Part> associatedParts = FXCollections.observableArrayList(associatedPartsBuffer);
        return new Product(associatedParts, generateId(1), name, price, inv, min, max);
    }
}
