package viewcontrollers;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import model.Inventory;
import model.Part;
import model.Product;

import java.io.IOException;
import java.net.URL;
import java.util.ResourceBundle;

import static model.Utilities.populatePartsTable;
import static model.Utilities.populateProductTable;
import static viewcontrollers.AddModifyController.setSelectedPart;
import static viewcontrollers.AddModifyController.setSelectedProduct;

// BUG-LOG
// 01/16/22: Delete button not working after the tableview has been altered via the search field.
// FIXED on 01/16/22 - Although the deletion handler was, in fact, deleting the selected inventory item from inventory,
// it did *not* delete that item from the list of search results being depicted by the TableView following a search query.
// The simple solution was to add an extra statement in the deletion handler such that the selected inventory
// item is deleted from both inventory and the result list being depicted at that time.
/** Manages user interaction with the program's main screen. */
public class MainScreen extends Controller implements Initializable {

    public TextField partSearchField;
    public TextField productSearchField;

    public TableView<Part> partsTable;
    public TableColumn<Part, Integer> partId;
    public TableColumn<Part, String> partName;
    public TableColumn<Part, Integer> partStock;
    public TableColumn<Part, Double> partPrice;
    public Button partAddButton;
    public Button partModButton;
    public Button partDelButton;

    public TableView<Product> productsTable;
    public TableColumn<Product, Integer> productId;
    public TableColumn<Product, String> productName;
    public TableColumn<Product, Integer> productStock;
    public TableColumn<Product, Double> productPrice;
    public Button productAddButton;
    public Button productModButton;
    public Button productDelButton;
    public Button exitButton;

    /** Initializes this view and creates the table columsn which will eventually store the properties of Parts and Products. */
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        // Associating table columns with appropriate object properties.
        populatePartsTable(Inventory.getAllParts(), partsTable, partId, partName, partStock, partPrice);
        populateProductTable(Inventory.getAllProducts(), productsTable, productId, productName, productStock,
                productPrice);
    }

    /** Event handler for the Add Part button.
     *
     * @param actionEvent The event generated by interaction with the Add Part button.
     */
    public void onPartAdd(ActionEvent actionEvent) throws IOException{
        loadScene(actionEvent, "Add Part", "AddModifyPart", "550x450");
    }

    /** Event handler for the Modify Part button.
     *
     * @param actionEvent The event generated by interaction with the Modify Part button.
     */
    public void onPartMod(ActionEvent actionEvent) throws IOException{
        Part selectedPart = partsTable.getSelectionModel().getSelectedItem();
        if(selectedPart != null) {
            setSelectedPart(selectedPart);
            loadScene(actionEvent, "Modify Part", "AddModifyPart", "550x450");
        } else {
            System.out.println("Not part has been selected.");
        }
    }

    /** Event handler for the Delete Part button. */
    public void onPartDel() {
        Part selectedPart = partsTable.getSelectionModel().getSelectedItem();
        Alert alert = new Alert(Alert.AlertType.CONFIRMATION, selectedPart.getName() +
                " will be deleted. Are you sure?", ButtonType.YES, ButtonType.NO);
        alert.showAndWait();
        if (alert.getResult() == ButtonType.YES) {
            boolean deletedFromTableView = partsTable.getItems().remove(selectedPart);
            if(!deletedFromTableView){
                Alert alert2 = new Alert(Alert.AlertType.ERROR);
                alert2.setTitle("No Part Selected");
                alert2.setContentText("No part has been selected for deletion.");
                alert2.showAndWait();
            }
        }
    }

    /** Event handler for the Add Product button.
     *
     * @param actionEvent The event generated by interaction with the Add Product button.
     */
    public void onProductAdd(ActionEvent actionEvent) throws IOException {
        loadScene(actionEvent, "Add Product", "AddModifyProduct","500x900");
    }

    /** Event handler for the Modify Product button.
     *
     * @param actionEvent The event generated by interaction with the Modify Product button.
     */
    public void onProductMod(ActionEvent actionEvent) throws IOException {
        Product selectedProduct = productsTable.getSelectionModel().getSelectedItem();
        if(selectedProduct != null) {
            setSelectedProduct(selectedProduct);
            loadScene(actionEvent, "Modify Product", "AddModifyProduct","500x900");
        } else {
            System.out.println("No product has been selected.");
        }

    }

    /** Event handler for the Delete Product button. */
    public void onProductDel() {
        Product selectedProduct = productsTable.getSelectionModel().getSelectedItem();
        if(selectedProduct.getAllAssociatedParts().isEmpty()) {
            Alert alert = new Alert(Alert.AlertType.CONFIRMATION, selectedProduct.getName() +
                    " will be deleted. Are you sure?", ButtonType.YES, ButtonType.NO);
            alert.showAndWait();
            if (alert.getResult() == ButtonType.YES) {
                boolean deletedFromTableView = productsTable.getItems().remove(selectedProduct);
                if(!deletedFromTableView) {
                    Alert alert2 = new Alert(Alert.AlertType.ERROR);
                    alert2.setTitle("No Product Selected");
                    alert2.setContentText("No product has been selected for deletion.");
                    alert2.showAndWait();
                }
            }
        } else {
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle("Product Has Associated Parts");
            alert.setContentText("This product has parts associated with it. Remove them and try again!");
            alert.showAndWait();
        }
    }

    /** Event handler for both the Part and Product search boxes. Triggered when enter is pressed while
     * the search box in question is selected.
     *
     * @param keyEvent The event generated by the user when a key is pressed while a search box is selected.
     */
    public void onSearchKeyPress(KeyEvent keyEvent) {
        if(keyEvent.getCode().equals(KeyCode.ENTER)) {

            TextField field = (TextField) keyEvent.getSource();
            String searchTerm = field.getText();
            String fieldId = field.getId();
            if(fieldId.equals("partSearchField")) {
                ObservableList<Part> parts = FXCollections.observableArrayList();
                try {
                    // Check whether the search term is an integer id.
                    int id = Integer.parseInt(searchTerm);
                    parts.add(Inventory.lookupPart(id));
                } catch(NumberFormatException e) {
                    // In the event that it is not an integer id, we will search by name instead.
                    parts = Inventory.lookupPart(searchTerm.toLowerCase());
                }
                if(parts.isEmpty()) {
                    Alert alert = new Alert(Alert.AlertType.ERROR);
                    alert.setTitle("Part(s) Not Found");
                    alert.setContentText("No matching parts were found!");
                    alert.showAndWait();
                }
                populatePartsTable(parts, partsTable, partId, partName, partStock, partPrice);
            }else if(fieldId.equals("productSearchField")) {
                ObservableList<Product> products = FXCollections.observableArrayList();
                try {
                    int id = Integer.parseInt(searchTerm);
                    products.add(Inventory.lookupProduct(id));
                } catch(NumberFormatException e) {
                    products = Inventory.lookupProduct(searchTerm.toLowerCase());
                }
                if(products.isEmpty()) {
                    Alert alert = new Alert(Alert.AlertType.ERROR);
                    alert.setTitle("Product(s) Not Found");
                    alert.setContentText("No matching products were found!");
                    alert.showAndWait();
                }
                populateProductTable(products, productsTable, productId, productName, productStock,
                        productPrice);
            }
        }
    }

    /** Event handler for the Exit button. */
    public void shutDown(ActionEvent actionEvent) {
        Platform.exit();
    }
}
